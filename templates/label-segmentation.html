<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diatom Segmentation</title>
    
    <!-- External Dependencies -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    
    <!-- Custom Styles -->
    <style>
        @keyframes slide-up {
            from { transform: translateY(100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .animate-slide-up {
            animation: slide-up 0.3s ease-out;
        }
        circle {
            transition: stroke-dashoffset 0.3s ease;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
    // =====================================
    // Utility Functions
    // =====================================
    
    const calculatePolygonData = (points, imageWidth, imageHeight) => {
        // Extract x and y coordinates
        const denormXs = points.map(p => p.x);
        const denormYs = points.map(p => p.y);
        
        // Calculate bounding points
        const topLeft = {
            x: Math.min(...denormXs),
            y: Math.min(...denormYs)
        };
        
        const bottomRight = {
            x: Math.max(...denormXs),
            y: Math.max(...denormYs)
        };
        
        // Calculate dimensions
        const width = bottomRight.x - topLeft.x;
        const height = bottomRight.y - topLeft.y;
        const centerX = topLeft.x + width / 2;
        const centerY = topLeft.y + height / 2;
        
        // Create normalized points
        const normalizedPoints = points.map(point => ({
            x: point.x / imageWidth,
            y: point.y / imageHeight
        }));
        
        // Create YOLO format bbox
        const yoloBBox = [
            centerX / imageWidth,
            centerY / imageHeight,
            width / imageWidth,
            height / imageHeight
        ];
        
        return {
            norm_polygon_points: normalizedPoints,
            denorm_polygon_points: points,
            denorm_xs: denormXs,
            denorm_ys: denormYs,
            denorm_top_left: topLeft,
            denorm_bottom_right: bottomRight,
            denorm_bbox: `${topLeft.x},${topLeft.y} ${bottomRight.x},${bottomRight.y}`,
            denorm_calculated_yolobbox: yoloBBox,
            image_width: imageWidth,
            image_height: imageHeight
        };
    };

    const generateSegmentationText = (polygons, imageWidth, imageHeight) => {
        return polygons.map(polygon => {
            const normalizedPoints = polygon.points.map(point => {
                const x = point.x / imageWidth;
                const y = point.y / imageHeight;
                return `${x.toFixed(6)} ${y.toFixed(6)}`;
            }).join(' ');
            return `${polygon.label} ${normalizedPoints}`;
        }).join('\n');
    };

    const parseSegmentationText = (text, imageWidth, imageHeight) => {
        if (!text.trim()) return [];
        
        return text.trim().split('\n').map(line => {
            const [label, ...coords] = line.split(' ');
            const points = [];
            
            for (let i = 0; i < coords.length; i += 2) {
                if (coords[i] && coords[i+1]) {
                    points.push({
                        x: parseFloat(coords[i]) * imageWidth,
                        y: parseFloat(coords[i+1]) * imageHeight
                    });
                }
            }
            
            return {
                label: parseInt(label),
                points,
                color: getRandomColor()
            };
        }).filter(polygon => polygon.points.length >= 3);
    };

    const getRandomColor = () => {
        const colors = ['#2ecc71', '#e74c3c', '#3498db', '#f1c40f', '#9b59b6', '#1abc9c'];
        return colors[Math.floor(Math.random() * colors.length)];
    };

// =====================================
    // Component Definitions
    // =====================================
    
    const CircularProgress = ({ progress }) => {
        const radius = 20;
        const circumference = 2 * Math.PI * radius;
        const strokeDashoffset = circumference - (progress / 100) * circumference;
        
        return (
            <svg className="transform -rotate-90 w-12 h-12">
                <circle
                    className="text-gray-300"
                    strokeWidth="4"
                    stroke="currentColor"
                    fill="transparent"
                    r={radius}
                    cx="24"
                    cy="24"
                />
                <circle
                    className="text-green-500"
                    strokeWidth="4"
                    strokeDasharray={circumference}
                    strokeDashoffset={strokeDashoffset}
                    strokeLinecap="round"
                    stroke="currentColor"
                    fill="transparent"
                    r={radius}
                    cx="24"
                    cy="24"
                />
                <text
                    x="24"
                    y="24"
                    className="text-xs font-medium"
                    fill="currentColor"
                    textAnchor="middle"
                    alignmentBaseline="middle"
                    transform="rotate(90 24 24)"
                >
                    {Math.round(progress)}%
                </text>
            </svg>
        );
    };

    const Toast = ({ message, onClose }) => {
        React.useEffect(() => {
            const timer = setTimeout(() => {
                onClose();
            }, 3000);
            return () => clearTimeout(timer);
        }, [onClose]);

        return (
            <div className="fixed bottom-4 right-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg flex items-center space-x-2 animate-slide-up">
                <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M5 13l4 4L19 7" />
                </svg>
                <span>{message}</span>
            </div>
        );
    };

    const DiatomSelector = ({ selected, setSelected }) => {
        const options = [
            { label: 'Incomplete Diatom', value: 0 },
            { label: 'Complete Diatom', value: 1 },
            { label: 'Fragment Diatom', value: 2 },
            { label: 'Blurred Diatom', value: 3 },
            { label: 'Diatom SideView', value: 4 }
        ];

        return (
            <div className="p-4">
                <div className="flex flex-wrap gap-6 items-center justify-center">
                    {options.map((option) => (
                        <label key={option.value} className="flex items-center space-x-2 cursor-pointer">
                            <input
                                type="radio"
                                name="diatom-type"
                                value={option.value}
                                checked={selected === option.value}
                                onChange={(e) => setSelected(Number(e.target.value))}
                                className="w-4 h-4 text-blue-600 cursor-pointer"
                            />
                            <span className="text-sm font-medium text-gray-700">
                                {option.label}
                            </span>
                        </label>
                    ))}
                </div>
            </div>
        );
    };

    const SegmentationButtons = ({ 
        onSave, 
        onUpdate, 
        onDownload, 
        isSaving, 
        isUpdating,
        saveProgress,
        hasSegmentations 
    }) => {
        return (
            <div className="flex justify-center space-x-4">
                <button 
                    onClick={onSave}
                    disabled={isSaving}
                    className={`
                        px-8 py-3 rounded-lg font-bold transform transition-all duration-200
                        flex items-center justify-center min-w-[120px]
                        ${isSaving 
                            ? 'bg-gray-400 cursor-not-allowed'
                            : 'bg-green-600 text-white hover:bg-green-500 hover:scale-105 hover:shadow-lg'
                        }
                    `}
                >
                    {isSaving ? (
                        <div className="flex items-center space-x-2">
                            <CircularProgress progress={saveProgress} />
                            <span className="text-white">Saving...</span>
                        </div>
                    ) : (
                        <span>Save</span>
                    )}
                </button>

                <button 
                    onClick={onUpdate}
                    disabled={!hasSegmentations || isUpdating}
                    className={`
                        px-8 py-3 rounded-lg font-bold transform transition-all duration-200
                        flex items-center justify-center min-w-[180px]
                        ${(!hasSegmentations || isUpdating)
                            ? 'bg-gray-400 cursor-not-allowed'
                            : 'bg-blue-600 text-white hover:bg-blue-500 hover:scale-105 hover:shadow-lg'
                        }
                    `}
                >
                    {isUpdating ? (
                        <div className="flex items-center space-x-2">
                            <svg className="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            <span>Updating...</span>
                        </div>
                    ) : (
                        <div className="flex items-center space-x-2">
                            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                            </svg>
                            <span>Update Segmentation Data</span>
                        </div>
                    )}
                </button>

                <button 
                    onClick={onDownload}
                    className="
                        bg-yellow-400 text-black px-8 py-3 rounded-lg font-bold
                        transform transition-all duration-200 
                        hover:scale-105 hover:bg-yellow-300 hover:shadow-lg
                        flex items-center space-x-2
                    "
                >
                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                    </svg>
                    <span>Download</span>
                </button>
            </div>
        );
    };

    const SegmentationList = ({ polygons, selectedIndex, onSelectSegment, getDiatomLabel }) => {
        return (
            <div className="mt-4 space-y-2 px-4">
                {polygons.map((polygon, index) => (
                    <div
                        key={index}
                        onClick={() => onSelectSegment(index)}
                        className={`p-3 rounded-lg cursor-pointer transition-all duration-200 ${
                            selectedIndex === index 
                                ? 'bg-blue-600 text-white shadow-lg transform scale-105' 
                                : 'bg-gray-700 text-gray-200 hover:bg-gray-600'
                        }`}
                    >
                        <div className="flex items-center justify-between">
                            <span className="font-medium">
                                {index + 1}. {getDiatomLabel(polygon.label)}
                            </span>
                            <div 
                                className="w-4 h-4 rounded-full" 
                                style={{ backgroundColor: polygon.color }}
                            />
                        </div>
                        
                        {selectedIndex === index && (
                        <div className="mt-2 text-sm opacity-80">
                            <div>Points: {polygon.points.length}</div>
                            {polygon.denorm_bbox && (
                                <div>Bbox: {polygon.denorm_bbox}</div>
                            )}
                        </div>
                    )}
                </div>
            ))}
        </div>
    );
};

const Sidebar = ({ polygons, selectedIndex, onSelectSegment, getDiatomLabel }) => {
    return (
        <div className="w-96 bg-gray-800 fixed right-0 h-full overflow-y-auto">
            <div className="text-2xl font-bold text-white text-center py-5 border-b border-gray-700">
                Polygons ({polygons.length})
            </div>
            
            <div className="p-4 text-white">
                <p>Instructions:</p>
                <ul className="list-disc pl-5 space-y-2 mt-2">
                    <li>Click to start drawing a polygon</li>
                    <li>Click to add points to the polygon</li>
                    <li>Click near the start point to close the polygon</li>
                    <li>Press ESC to cancel current polygon</li>
                    <li>Click on a segmentation in the list to highlight it</li>
                </ul>
            </div>
            
            <SegmentationList 
                polygons={polygons}
                selectedIndex={selectedIndex}
                onSelectSegment={onSelectSegment}
                getDiatomLabel={getDiatomLabel}
            />
        </div>
    );
};


const Canvas = ({
        imageUrl,
        polygons,
        currentPolygon,
        selectedSegmentIndex,
        isDrawing,
        onCanvasClick,
        onMouseMove,
        getDiatomLabel,
        containerRef,
        canvasRef,
        imageRef,
        onImageLoad
    }) => {
        const drawPolygons = () => {
            const canvas = canvasRef.current;
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw completed polygons
            polygons.forEach((polygon, index) => {
                if (polygon.points.length < 3) return;

                ctx.beginPath();
                ctx.moveTo(polygon.points[0].x, polygon.points[0].y);
                for (let i = 1; i < polygon.points.length; i++) {
                    ctx.lineTo(polygon.points[i].x, polygon.points[i].y);
                }
                ctx.closePath();
                
                const isSelected = index === selectedSegmentIndex;
                
                if (isSelected) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 4;
                    ctx.stroke();
                    
                    ctx.strokeStyle = polygon.color;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    ctx.fillStyle = `${polygon.color}80`;
                } else {
                    ctx.strokeStyle = polygon.color;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    ctx.fillStyle = `${polygon.color}40`;
                }
                ctx.fill();
                
                if (isSelected) {
                    const centerX = polygon.points.reduce((sum, p) => sum + p.x, 0) / polygon.points.length;
                    const centerY = polygon.points.reduce((sum, p) => sum + p.y, 0) / polygon.points.length;
                    
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#ffffff';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 3;
                    
                    const text = `${index + 1}. ${getDiatomLabel(polygon.label)}`;
                    ctx.strokeText(text, centerX, centerY);
                    ctx.fillText(text, centerX, centerY);
                }
            });

            // Draw current polygon
            if (currentPolygon.length > 0) {
                ctx.beginPath();
                ctx.moveTo(currentPolygon[0].x, currentPolygon[0].y);
                for (let i = 1; i < currentPolygon.length; i++) {
                    ctx.lineTo(currentPolygon[i].x, currentPolygon[i].y);
                }
                if (isDrawing) {
                    ctx.lineTo(currentPolygon[currentPolygon.length - 1].x, currentPolygon[currentPolygon.length - 1].y);
                }
                
                ctx.strokeStyle = '#2ecc71';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        };

        React.useEffect(() => {
            drawPolygons();
        }, [polygons, currentPolygon, selectedSegmentIndex]);

        return (
            <div 
                ref={containerRef}
                className="relative w-full max-w-4xl mt-4"
            >
                <img
                    ref={imageRef}
                    src={imageUrl}
                    alt="Diatom"
                    className="w-full"
                    onLoad={() => {
                        const canvas = canvasRef.current;
                        const container = containerRef.current;
                        const image = imageRef.current;
                        
                        if (canvas && container && image) {
                            canvas.width = container.offsetWidth;
                            canvas.height = container.offsetHeight;
                            onImageLoad?.();
                            drawPolygons();
                        }
                    }}
                />
                <canvas
                    ref={canvasRef}
                    className="absolute top-0 left-0 w-full h-full cursor-crosshair"
                    onClick={onCanvasClick}
                    onMouseMove={onMouseMove}
                />
            </div>
        );
    };

    const App = () => {
        // State declarations
        const [imageIndex, setImageIndex] = React.useState(0);
        const [totalImages, setTotalImages] = React.useState(0);
        const [polygons, setPolygons] = React.useState([]);
        const [currentPolygon, setCurrentPolygon] = React.useState([]);
        const [isDrawing, setIsDrawing] = React.useState(false);
        const [imageUrl, setImageUrl] = React.useState('');
        const [isSaving, setIsSaving] = React.useState(false);
        const [isUpdating, setIsUpdating] = React.useState(false);
        const [saveProgress, setSaveProgress] = React.useState(0);
        const [showToast, setShowToast] = React.useState(false);
        const [toastMessage, setToastMessage] = React.useState('');
        const [selectedType, setSelectedType] = React.useState(1);
        const [imageData, setImageData] = React.useState(null);
        const [selectedSegmentIndex, setSelectedSegmentIndex] = React.useState(null);
        const [error, setError] = React.useState(null);

        // Refs
        const canvasRef = React.useRef(null);
        const imageRef = React.useRef(null);
        const containerRef = React.useRef(null);

        // Load image data
        React.useEffect(() => {
            loadImageData(imageIndex);
        }, [imageIndex]);

        const loadImageData = async (index) => {
            try {
                const response = await fetch(`/api/diatoms?index=${index}`);
                const data = await response.json();
                
                if (data.error) {
                    setError(data.error);
                    return;
                }

                setImageUrl(data.data.image_url);
                setImageData(data.data);
                setTotalImages(data.total_images);
                setImageIndex(data.current_index);
                setSelectedSegmentIndex(null);

                if (data.data.segmentation_url) {
                    const segResponse = await fetch(
                        `/api/get_segmentation?url=${encodeURIComponent(data.data.segmentation_url)}&image_index=${index}`
                    );
                    
                    if (!segResponse.ok) {
                        throw new Error('Failed to fetch segmentation data');
                    }
                    
                    const segData = await segResponse.json();
                    if (segData.annotations) {
                        const processedPolygons = parseSegmentationText(
                            segData.annotations,
                            data.data.image_width,
                            data.data.image_height
                        );
                        setPolygons(processedPolygons);
                    }
                } else {
                    setPolygons([]);
                }
            } catch (error) {
                setError('Failed to load image data');
                console.error('Error:', error);
            }
        };

        const handleUpdateSegmentations = async () => {
            setIsUpdating(true);
            setError(null);
            
            try {
                const response = await fetch('/api/update_segmentations', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image_index: imageIndex })
                });
                
                const data = await response.json();
                
                if (!data.success) {
                    throw new Error(data.error || 'Update failed');
                }
                
                setToastMessage(`Successfully updated ${data.updated_count} segmentations`);
                setShowToast(true);
                
                await loadImageData(imageIndex);
                
            } catch (error) {
                setError(error.message || 'Failed to update segmentations');
            } finally {
                setIsUpdating(false);
            }
        };

        const handleCanvasClick = async (e) => {
            const rect = canvasRef.current.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (!isDrawing) {
                setIsDrawing(true);
                setCurrentPolygon([{ x, y }]);
            } else {
                const startPoint = currentPolygon[0];
                const distance = Math.sqrt(
                    Math.pow(x - startPoint.x, 2) + Math.pow(y - startPoint.y, 2)
                );

                if (distance < 20 && currentPolygon.length > 2) {
                    const newPolygon = {
                        label: selectedType,
                        points: currentPolygon,
                        color: getRandomColor()
                    };
                    
                    const updatedPolygons = [...polygons, newPolygon];
                    setPolygons(updatedPolygons);
                    setCurrentPolygon([]);
                    setIsDrawing(false);
                    
                    await handleSave(updatedPolygons);
                } else {
                    setCurrentPolygon([...currentPolygon, { x, y }]);
                }
            }
        };

        const handleSave = async (polygonsToSave = polygons) => {
            setIsSaving(true);
            setSaveProgress(0);
            setError(null);
            
            const progressInterval = setInterval(() => {
                setSaveProgress(prev => Math.min(prev + 10, 90));
            }, 100);

            try {
                const imageFileName = imageUrl.split('/').pop().replace(/\.[^/.]+$/, '');
                
                // Calculate enhanced data for each polygon
                const enhancedPolygons = polygonsToSave.map(polygon => {
                    const enhancedData = calculatePolygonData(
                        polygon.points,
                        imageData.image_width,
                        imageData.image_height
                    );
                    
                    return {
                        ...polygon,
                        ...enhancedData
                    };
                });

                const response = await fetch('/api/save_segmentation', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image_index: imageIndex,
                        segmentation_data: generateSegmentationText(
                            enhancedPolygons,
                            imageData.image_width,
                            imageData.image_height
                        ),
                        image_filename: imageFileName,
                        segmentation_indices: enhancedPolygons
                    })
                });
                
                const data = await response.json();
                
                clearInterval(progressInterval);
                setSaveProgress(100);
                
                if (data.success) {
                    setToastMessage('Segmentation saved successfully!');
                    setShowToast(true);
                    setImageData(prev => ({
                        ...prev,
                        segmentation_url: data.segmentation_url,
                        segmentation_indices_array: data.segmentation_indices_array
                    }));
                } else {
                    throw new Error(data.error || 'Save failed');
                }
            } catch (error) {
                setError(error.message || 'Failed to save segmentation');
            } finally {
                setTimeout(() => {
                    setIsSaving(false);
                    setSaveProgress(0);
                }, 500);
            }
        };

        const getDiatomLabel = (value) => {
            const labels = {
                0: 'Incomplete Diatom',
                1: 'Complete Diatom',
                2: 'Fragment Diatom',
                3: 'Blurred Diatom',
                4: 'Diatom SideView'
            };
            return labels[value] || 'Unknown';
        };

        const handleKeyPress = (e) => {
            if (e.key === 'Escape' && isDrawing) {
                setCurrentPolygon([]);
                setIsDrawing(false);
            }
        };

        React.useEffect(() => {
            document.addEventListener('keydown', handleKeyPress);
            return () => {
                document.removeEventListener('keydown', handleKeyPress);
            };
        }, [isDrawing]);

        const handlePrevious = () => {
            setImageIndex(prev => Math.max(0, prev - 1));
        };

        const handleNext = () => {
            setImageIndex(prev => Math.min(totalImages - 1, prev + 1));
        };

        const handleMouseMove = (e) => {
            if (!isDrawing || !canvasRef.current) return;
            const canvas = canvasRef.current;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Redraw existing polygons
            polygons.forEach(polygon => {
                if (polygon.points.length < 3) return;
                ctx.beginPath();
                ctx.moveTo(polygon.points[0].x, polygon.points[0].y);
                polygon.points.forEach(point => {
                    ctx.lineTo(point.x, point.y);
                });
                ctx.closePath();
                ctx.strokeStyle = polygon.color;
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = `${polygon.color}40`;
                ctx.fill();
            });

            // Draw current polygon
            if (currentPolygon.length > 0) {
                ctx.beginPath();
                ctx.moveTo(currentPolygon[0].x, currentPolygon[0].y);
                currentPolygon.forEach(point => {
                    ctx.lineTo(point.x, point.y);
                });
                ctx.strokeStyle = '#2ecc71';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        };

        return (
            <div className="flex h-screen bg-gray-200">
                {/* Left Sidebar */}
                <div className="w-64 bg-gray-800 fixed h-full">
                    <img 
                        src="/static/diatomhub-images/logo/diatom_hub_5e.svg" 
                        alt="DiatomHub Logo" 
                        className="w-4/5 mx-auto mt-5"
                    />
                    
                    <div className="flex flex-col gap-3 px-4 mt-6">
                        <a href="/modules" 
                           className="px-4 py-3 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 transition-colors duration-200">
                            View Installed Modules
                        </a>
                        <a href="/all_papers" 
                           className="px-4 py-3 text-sm font-medium text-white bg-transparent border border-white rounded-md hover:bg-white/10 transition-colors duration-200">
                            View Papers
                        </a>
                        <a href="/diatoms_data" 
                           className="px-4 py-3 text-sm font-medium text-white bg-transparent border border-white rounded-md hover:bg-white/10 transition-colors duration-200">
                            View Diatoms Data
                        </a>
                        <a href="/label" 
                           className="px-4 py-3 text-sm font-medium text-white bg-transparent border border-white rounded-md hover:bg-white/10 transition-colors duration-200">
                            Label Images
                        </a>
                    </div>
                </div>

                {/* Main Content */}
                <div className="flex-1 ml-64 mr-96">
                    <div className="flex flex-col items-center justify-center min-h-screen p-5">
                        <div className="text-4xl font-bold mb-4 text-gray-800">
                            Diatom Segmentation
                        </div>
                        
                        <DiatomSelector 
                            selected={selectedType}
                            setSelected={setSelectedType}
                        />
                        
                        <Canvas
                            imageUrl={imageUrl}
                            polygons={polygons}
                            currentPolygon={currentPolygon}
                            selectedSegmentIndex={selectedSegmentIndex}
                            isDrawing={isDrawing}
                            onCanvasClick={handleCanvasClick}
                            onMouseMove={handleMouseMove}
                            getDiatomLabel={getDiatomLabel}
                            containerRef={containerRef}
                            canvasRef={canvasRef}
                            imageRef={imageRef}
                        />
                        
                        <div className="flex justify-center space-x-4 mt-6">
                            <button 
                                onClick={handlePrevious}
                                disabled={imageIndex === 0}
                                className="bg-yellow-400 text-black px-8 py-3 rounded-lg font-bold disabled:opacity-50 transform transition-all duration-200 hover:scale-105 hover:bg-yellow-300 hover:shadow-lg"
                            >
                                Previous
                            </button>
                            
                            <SegmentationButtons 
                                onSave={() => handleSave()}
                                onUpdate={handleUpdateSegmentations}
                                onDownload={() => window.location.href = '/api/download_segmentation'}
                                isSaving={isSaving}
                                isUpdating={isUpdating}
                                saveProgress={saveProgress}
                                hasSegmentations={polygons.length > 0}
                            />
                            
                            <button 
                                onClick={handleNext}
                                disabled={imageIndex === totalImages - 1}
                                className="bg-yellow-400 text-black px-8 py-3 rounded-lg font-bold disabled:opacity-50 transform transition-all duration-200 hover:scale-105 hover:bg-yellow-300 hover:shadow-lg"
                            >
                                Next
                            </button>
                        </div>
                    </div>
                </div>

                {/* Right Sidebar */}
                <Sidebar 
                    polygons={polygons}
                    selectedIndex={selectedSegmentIndex}
                    onSelectSegment={setSelectedSegmentIndex}
                    getDiatomLabel={getDiatomLabel}
                />

                {/* Notifications */}
                {error && (
                    <div className="fixed top-4 right-4 bg-red-500 text-white px-6 py-3 rounded-lg shadow-lg">
                        {error}
                    </div>
                )}
                
                {showToast && (
                    <Toast 
                        message={toastMessage} 
                        onClose={() => setShowToast(false)} 
                    />
                )}
            </div>
        );
    };

    // Render the application
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
    </script>
</body>
</html>